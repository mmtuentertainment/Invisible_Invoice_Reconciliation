"""
Penetration testing framework for authentication system
Simulates real-world attack scenarios and vulnerability assessments
"""

import pytest
import asyncio
import time
import random
import string
import hashlib
import base64
import secrets
from datetime import datetime, timedelta
from uuid import uuid4
from typing import List, Dict, Any, Optional
from concurrent.futures import ThreadPoolExecutor
import requests
from httpx import AsyncClient

from app.main import app
from app.services.auth_service import AuthenticationService, LoginRequest, DeviceInfo
from app.models.auth import UserProfile, AuthAttempt, PasswordResetToken
from app.core.security import security
from app.core.config import settings
from app.core.database import get_db
from app.services.redis_service import redis_service
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession


class PenetrationTestResults:
    """Container for penetration test results"""
    
    def __init__(self):
        self.test_results = []
        self.vulnerabilities = []
        self.recommendations = []
    
    def add_test_result(self, test_name: str, passed: bool, details: str, risk_level: str = "LOW"):
        """Add test result"""
        self.test_results.append({
            "test_name": test_name,
            "passed": passed,
            "details": details,
            "risk_level": risk_level,
            "timestamp": datetime.utcnow().isoformat()
        })
        
        if not passed:
            self.vulnerabilities.append({
                "test_name": test_name,
                "risk_level": risk_level,
                "details": details
            })
    
    def add_recommendation(self, recommendation: str):
        """Add security recommendation"""
        self.recommendations.append(recommendation)
    
    def get_summary(self) -> Dict[str, Any]:
        """Get test summary"""
        total_tests = len(self.test_results)
        passed_tests = sum(1 for t in self.test_results if t["passed"])
        failed_tests = total_tests - passed_tests
        
        risk_counts = {"HIGH": 0, "MEDIUM": 0, "LOW": 0}
        for vuln in self.vulnerabilities:
            risk_counts[vuln["risk_level"]] += 1
        
        return {
            "total_tests": total_tests,
            "passed_tests": passed_tests,
            "failed_tests": failed_tests,
            "vulnerabilities": len(self.vulnerabilities),
            "risk_distribution": risk_counts,
            "recommendations_count": len(self.recommendations)
        }


@pytest.mark.pentest
class TestAuthenticationPenetration:
    """Penetration testing for authentication system"""
    
    @pytest.fixture
    async def db_session(self):
        """Get database session for tests"""
        async for session in get_db():
            yield session
    
    @pytest.fixture
    async def test_client(self):
        """Get test client"""
        async with AsyncClient(app=app, base_url="http://testserver") as client:
            yield client
    
    @pytest.fixture
    async def pentest_user(self, db_session: AsyncSession):
        """Create test user for penetration testing"""
        user = UserProfile(
            id=uuid4(),
            tenant_id=uuid4(),
            email="pentest@security.com",
            password_hash=security.hash_password("PentestPassword123!"),
            full_name="Penetration Test User",
            auth_status="active",
            created_at=datetime.utcnow()
        )
        
        db_session.add(user)
        await db_session.commit()
        
        yield user
        
        # Cleanup
        await db_session.delete(user)
        await db_session.commit()
    
    @pytest.fixture
    def pentest_results(self):
        """Initialize penetration test results container"""
        return PenetrationTestResults()
    
    @pytest.mark.asyncio
    async def test_brute_force_resistance(self, db_session, pentest_user, pentest_results):
        """Test resistance to brute force attacks"""
        auth_service = AuthenticationService(db_session)
        device_info = DeviceInfo(
            ip_address="10.0.0.1",
            user_agent="Brute Force Bot",
            fingerprint="bruteforce_device"
        )
        
        # Clear existing rate limits
        await redis_service.client.flushdb()
        
        # Common passwords to try
        common_passwords = [
            "password", "123456", "password123", "admin", "qwerty",
            "letmein", "welcome", "monkey", "1234567890", "password1"
        ]
        
        successful_attempts = 0
        rate_limited = False
        locked_account = False
        
        for i, password in enumerate(common_passwords * 2):  # Try each password twice
            login_request = LoginRequest(
                email=pentest_user.email,
                password=password
            )
            
            result = await auth_service.authenticate_user(login_request, device_info)
            
            if result.success:
                successful_attempts += 1
                break
            
            if "too many" in result.error.lower():
                rate_limited = True
                break
                
            if "locked" in result.error.lower():
                locked_account = True
                break
            
            await asyncio.sleep(0.1)  # Small delay
        
        # Evaluate results
        if successful_attempts > 0:
            pentest_results.add_test_result(
                "Brute Force Resistance",
                False,
                f"Brute force attack succeeded after {i+1} attempts",
                "HIGH"
            )
        elif rate_limited and locked_account:
            pentest_results.add_test_result(
                "Brute Force Resistance",
                True,
                "System properly implements rate limiting and account lockout",
                "LOW"
            )
        else:
            pentest_results.add_test_result(
                "Brute Force Resistance",
                False,
                "Insufficient brute force protection mechanisms",
                "MEDIUM"
            )
    
    @pytest.mark.asyncio
    async def test_credential_stuffing_attack(self, db_session, pentest_results):
        """Test resistance to credential stuffing attacks"""
        auth_service = AuthenticationService(db_session)
        
        # Simulated leaked credentials (common email/password combinations)
        leaked_credentials = [
            ("admin@company.com", "password123"),
            ("user@example.com", "123456"),
            ("test@test.com", "password"),
            ("admin@admin.com", "admin"),
            ("user@user.com", "user123")
        ]
        
        successful_logins = 0
        rate_limited_ips = set()
        
        for i, (email, password) in enumerate(leaked_credentials):
            device_info = DeviceInfo(
                ip_address=f"192.168.1.{i+1}",
                user_agent=f"CredStuffer Bot {i}",
                fingerprint=f"stuffing_device_{i}"
            )
            
            login_request = LoginRequest(email=email, password=password)
            result = await auth_service.authenticate_user(login_request, device_info)
            
            if result.success:
                successful_logins += 1
            elif "too many" in result.error.lower():
                rate_limited_ips.add(device_info.ip_address)
            
            await asyncio.sleep(0.1)
        
        # Evaluate results
        if successful_logins > 0:
            pentest_results.add_test_result(
                "Credential Stuffing Resistance",
                False,
                f"Credential stuffing succeeded with {successful_logins} accounts",
                "HIGH"
            )
        else:
            pentest_results.add_test_result(
                "Credential Stuffing Resistance", 
                True,
                "No accounts compromised via credential stuffing",
                "LOW"
            )
        
        # Check if rate limiting is working across different IPs
        if len(rate_limited_ips) < len(leaked_credentials) / 2:
            pentest_results.add_recommendation(
                "Consider implementing distributed rate limiting to better protect against credential stuffing"
            )
    
    @pytest.mark.asyncio
    async def test_session_hijacking_attack(self, db_session, pentest_user, pentest_results):
        """Test session hijacking attack vectors"""
        auth_service = AuthenticationService(db_session)
        
        # Legitimate login
        device_info = DeviceInfo(
            ip_address="192.168.1.100",
            user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            fingerprint="legitimate_device"
        )
        
        login_request = LoginRequest(
            email=pentest_user.email,
            password="PentestPassword123!"
        )
        
        result = await auth_service.authenticate_user(login_request, device_info)
        assert result.success is True
        
        legitimate_token = result.tokens.access_token
        
        # Attempt session hijacking with different device fingerprint
        attacker_device = DeviceInfo(
            ip_address="192.168.1.200",  # Different IP
            user_agent="Malicious Bot/1.0",  # Different user agent
            fingerprint="attacker_device"  # Different fingerprint
        )
        
        # Try to use legitimate refresh token from attacker device
        hijack_result = await auth_service.refresh_access_token(
            result.tokens.refresh_token,
            attacker_device
        )
        
        if hijack_result is not None:
            pentest_results.add_test_result(
                "Session Hijacking Resistance",
                False,
                "Session hijacking successful - refresh token worked from different device",
                "HIGH"
            )
        else:
            pentest_results.add_test_result(
                "Session Hijacking Resistance",
                True,
                "Session hijacking prevented by device fingerprint validation",
                "LOW"
            )
    
    @pytest.mark.asyncio
    async def test_jwt_token_vulnerabilities(self, pentest_user, pentest_results):
        """Test JWT token security vulnerabilities"""
        # Create legitimate token
        token = security.create_access_token(
            user_id=pentest_user.id,
            tenant_id=pentest_user.tenant_id,
            permissions=["test:read"]
        )
        
        # Test 1: None algorithm attack
        try:
            import jwt
            decoded = jwt.decode(token, options={"verify_signature": False})
            decoded["alg"] = "none"
            
            # Try to create unsigned token
            none_token = jwt.encode(decoded, "", algorithm="none")
            none_payload = security.verify_token(none_token)
            
            if none_payload is not None:
                pentest_results.add_test_result(
                    "JWT None Algorithm Attack",
                    False,
                    "JWT accepts 'none' algorithm - critical vulnerability",
                    "HIGH"
                )
            else:
                pentest_results.add_test_result(
                    "JWT None Algorithm Attack",
                    True,
                    "JWT properly rejects 'none' algorithm",
                    "LOW"
                )
        except Exception:
            pentest_results.add_test_result(
                "JWT None Algorithm Attack",
                True,
                "JWT none algorithm attack failed (good)",
                "LOW"
            )
        
        # Test 2: Token manipulation
        try:
            # Try to modify token payload
            token_parts = token.split('.')
            if len(token_parts) == 3:
                # Decode payload
                payload = jwt.decode(token, options={"verify_signature": False})
                
                # Attempt privilege escalation
                payload["permissions"] = ["admin:*", "system:*"]
                
                # Encode modified payload
                modified_payload = base64.b64encode(
                    str(payload).replace("'", '"').encode()
                ).decode().rstrip('=')
                
                # Create tampered token
                tampered_token = f"{token_parts[0]}.{modified_payload}.{token_parts[2]}"
                
                # Try to verify tampered token
                tampered_payload = security.verify_token(tampered_token)
                
                if tampered_payload is not None:
                    pentest_results.add_test_result(
                        "JWT Token Tampering",
                        False,
                        "Tampered JWT token accepted - signature verification bypassed",
                        "HIGH"
                    )
                else:
                    pentest_results.add_test_result(
                        "JWT Token Tampering",
                        True,
                        "JWT signature verification prevents token tampering",
                        "LOW"
                    )
        except Exception:
            pentest_results.add_test_result(
                "JWT Token Tampering",
                True,
                "Token tampering attempt failed (good)",
                "LOW"
            )
    
    @pytest.mark.asyncio
    async def test_password_reset_vulnerabilities(self, db_session, pentest_user, pentest_results):
        """Test password reset attack vectors"""
        # Test 1: Token brute force
        reset_token = security.generate_secure_token(32)
        token_hash = security.hash_password(reset_token)
        
        reset_record = PasswordResetToken(
            user_id=pentest_user.id,
            tenant_id=pentest_user.tenant_id,
            token_hash=token_hash,
            expires_at=datetime.utcnow() + timedelta(minutes=30),
            requested_ip="192.168.1.1"
        )
        
        db_session.add(reset_record)
        await db_session.commit()
        
        # Attempt to brute force reset token
        successful_guesses = 0
        attempts = 0
        
        for _ in range(1000):  # Limited attempts for test performance
            # Generate random token guess
            guess = ''.join(random.choices(string.ascii_letters + string.digits, k=32))
            
            # Check if guess matches
            if security.verify_password(guess, token_hash):
                successful_guesses += 1
                break
            
            attempts += 1
        
        if successful_guesses > 0:
            pentest_results.add_test_result(
                "Password Reset Token Brute Force",
                False,
                f"Reset token guessed after {attempts} attempts",
                "HIGH"
            )
        else:
            # Test token entropy
            token_entropy = len(set(reset_token))
            if token_entropy < 20:  # Low entropy
                pentest_results.add_test_result(
                    "Password Reset Token Entropy",
                    False,
                    f"Reset token has low entropy ({token_entropy} unique characters)",
                    "MEDIUM"
                )
            else:
                pentest_results.add_test_result(
                    "Password Reset Token Security",
                    True,
                    "Reset token has sufficient entropy and cannot be brute forced",
                    "LOW"
                )
    
    @pytest.mark.asyncio
    async def test_timing_attacks(self, db_session, pentest_user, pentest_results):
        """Test for timing attack vulnerabilities"""
        auth_service = AuthenticationService(db_session)
        device_info = DeviceInfo(
            ip_address="10.0.0.5",
            user_agent="Timing Attack Bot",
            fingerprint="timing_device"
        )
        
        # Test timing differences between valid and invalid emails
        valid_email_times = []
        invalid_email_times = []
        
        # Clear rate limits
        await redis_service.client.flushdb()
        
        # Test valid email with wrong password
        for i in range(20):
            start_time = time.perf_counter()
            
            login_request = LoginRequest(
                email=pentest_user.email,
                password=f"wrong_password_{i}"
            )
            await auth_service.authenticate_user(login_request, device_info)
            
            end_time = time.perf_counter()
            valid_email_times.append(end_time - start_time)
            
            await asyncio.sleep(0.2)  # Avoid rate limiting
        
        # Test invalid email
        for i in range(20):
            start_time = time.perf_counter()
            
            login_request = LoginRequest(
                email=f"invalid_{i}@nonexistent.com",
                password="any_password"
            )
            await auth_service.authenticate_user(login_request, device_info)
            
            end_time = time.perf_counter()
            invalid_email_times.append(end_time - start_time)
            
            await asyncio.sleep(0.2)
        
        # Analyze timing differences
        avg_valid = sum(valid_email_times) / len(valid_email_times)
        avg_invalid = sum(invalid_email_times) / len(invalid_email_times)
        timing_difference = abs(avg_valid - avg_invalid)
        
        # Statistical significance test (simplified)
        significant_difference = timing_difference > 0.1  # 100ms threshold
        
        if significant_difference:
            pentest_results.add_test_result(
                "Timing Attack Vulnerability",
                False,
                f"Timing difference of {timing_difference:.3f}s detected between valid/invalid emails",
                "MEDIUM"
            )
            pentest_results.add_recommendation(
                "Implement constant-time comparison for authentication to prevent timing attacks"
            )
        else:
            pentest_results.add_test_result(
                "Timing Attack Resistance",
                True,
                f"No significant timing difference detected ({timing_difference:.3f}s)",
                "LOW"
            )
    
    @pytest.mark.asyncio
    async def test_account_enumeration(self, db_session, pentest_user, pentest_results):
        """Test for account enumeration vulnerabilities"""
        auth_service = AuthenticationService(db_session)
        device_info = DeviceInfo(
            ip_address="10.0.0.10",
            user_agent="Enumeration Bot",
            fingerprint="enum_device"
        )
        
        # Test responses for existing vs non-existing accounts
        existing_email_responses = []
        nonexisting_email_responses = []
        
        # Test existing email
        for i in range(5):
            login_request = LoginRequest(
                email=pentest_user.email,
                password=f"wrong_password_{i}"
            )
            result = await auth_service.authenticate_user(login_request, device_info)
            existing_email_responses.append(result.error)
            
            await asyncio.sleep(0.5)
        
        # Test non-existing emails
        for i in range(5):
            login_request = LoginRequest(
                email=f"nonexistent_{i}@fake.com",
                password="any_password"
            )
            result = await auth_service.authenticate_user(login_request, device_info)
            nonexisting_email_responses.append(result.error)
            
            await asyncio.sleep(0.5)
        
        # Check if responses are identical
        unique_existing_responses = set(existing_email_responses)
        unique_nonexisting_responses = set(nonexisting_email_responses)
        
        # Check for information disclosure
        if unique_existing_responses != unique_nonexisting_responses:
            pentest_results.add_test_result(
                "Account Enumeration Vulnerability",
                False,
                "Different error messages for existing vs non-existing accounts",
                "MEDIUM"
            )
        else:
            pentest_results.add_test_result(
                "Account Enumeration Resistance",
                True,
                "Consistent error messages prevent account enumeration",
                "LOW"
            )
    
    @pytest.mark.asyncio
    async def test_rate_limiting_bypass(self, db_session, pentest_user, pentest_results):
        """Test various rate limiting bypass techniques"""
        auth_service = AuthenticationService(db_session)
        
        # Clear existing rate limits
        await redis_service.client.flushdb()
        
        # Test 1: X-Forwarded-For header manipulation
        bypass_successful = False
        
        # Make requests exceeding rate limit from same IP
        for i in range(10):
            # Try with X-Forwarded-For header spoofing
            device_info = DeviceInfo(
                ip_address="192.168.1.100",  # Same IP
                user_agent=f"Bypass Bot {i}",
                fingerprint=f"bypass_device_{i}"
            )
            
            login_request = LoginRequest(
                email=pentest_user.email,
                password="wrong_password"
            )
            
            result = await auth_service.authenticate_user(login_request, device_info)
            
            if i > 5 and "too many" not in result.error.lower():
                bypass_successful = True
            
            await asyncio.sleep(0.1)
        
        if bypass_successful:
            pentest_results.add_test_result(
                "Rate Limiting Bypass",
                False,
                "Rate limiting can be bypassed using header manipulation",
                "HIGH"
            )
        else:
            pentest_results.add_test_result(
                "Rate Limiting Security",
                True,
                "Rate limiting cannot be easily bypassed",
                "LOW"
            )
        
        # Test 2: Distributed attack from multiple IPs
        concurrent_attacks = []
        for i in range(20):
            device_info = DeviceInfo(
                ip_address=f"10.0.{i//5}.{i%5}",
                user_agent="Distributed Bot",
                fingerprint=f"distributed_device_{i}"
            )
            
            login_request = LoginRequest(
                email=pentest_user.email,
                password="distributed_attack"
            )
            
            concurrent_attacks.append(
                auth_service.authenticate_user(login_request, device_info)
            )
        
        # Execute distributed attack
        results = await asyncio.gather(*concurrent_attacks)
        successful_attempts = sum(1 for r in results if r.success)
        rate_limited_attempts = sum(1 for r in results if "too many" in r.error.lower())
        
        if successful_attempts > 0:
            pentest_results.add_test_result(
                "Distributed Rate Limiting Bypass",
                False,
                f"Distributed attack succeeded with {successful_attempts} successful attempts",
                "HIGH"
            )
        elif rate_limited_attempts < len(results) * 0.8:
            pentest_results.add_test_result(
                "Distributed Rate Limiting Weakness",
                False,
                "Distributed attack partially bypassed rate limiting",
                "MEDIUM"
            )
        else:
            pentest_results.add_test_result(
                "Distributed Rate Limiting Security",
                True,
                "Rate limiting effective against distributed attacks",
                "LOW"
            )
    
    @pytest.mark.asyncio
    async def test_mfa_bypass_attempts(self, db_session, pentest_user, pentest_results):
        """Test MFA bypass techniques"""
        auth_service = AuthenticationService(db_session)
        
        # Enable MFA for user
        mfa_result = await auth_service.setup_mfa(pentest_user.id, pentest_user.tenant_id)
        await auth_service.enable_mfa(pentest_user.id, pentest_user.tenant_id, "123456")  # Assume valid
        
        device_info = DeviceInfo(
            ip_address="10.0.0.15",
            user_agent="MFA Bypass Bot",
            fingerprint="mfa_bypass_device"
        )
        
        # Test 1: MFA code brute force
        login_request = LoginRequest(
            email=pentest_user.email,
            password="PentestPassword123!",
            mfa_token="000000"  # Start with common code
        )
        
        brute_force_attempts = 0
        mfa_bypassed = False
        
        # Try common MFA codes
        common_codes = ["000000", "123456", "111111", "000001", "123123"]
        
        for code in common_codes:
            login_request.mfa_token = code
            result = await auth_service.authenticate_user(login_request, device_info)
            brute_force_attempts += 1
            
            if result.success:
                mfa_bypassed = True
                break
            
            await asyncio.sleep(0.1)
        
        if mfa_bypassed:
            pentest_results.add_test_result(
                "MFA Brute Force Vulnerability",
                False,
                f"MFA bypassed via brute force after {brute_force_attempts} attempts",
                "HIGH"
            )
        else:
            pentest_results.add_test_result(
                "MFA Brute Force Resistance",
                True,
                "MFA codes cannot be easily brute forced",
                "LOW"
            )
        
        # Test 2: Backup code enumeration
        backup_codes = mfa_result.backup_codes
        if backup_codes:
            # Try to use invalid backup codes
            invalid_backup_attempts = 0
            for i in range(10):
                fake_code = f"{random.randint(1000, 9999)}-{random.randint(1000, 9999)}"
                login_request.mfa_token = fake_code
                
                result = await auth_service.authenticate_user(login_request, device_info)
                invalid_backup_attempts += 1
                
                if result.success:
                    pentest_results.add_test_result(
                        "MFA Backup Code Vulnerability",
                        False,
                        f"Invalid backup code accepted: {fake_code}",
                        "HIGH"
                    )
                    break
            else:
                pentest_results.add_test_result(
                    "MFA Backup Code Security",
                    True,
                    "Backup codes properly validated",
                    "LOW"
                )
    
    @pytest.mark.asyncio
    async def test_generate_penetration_report(self, pentest_results):
        """Generate comprehensive penetration test report"""
        # Add final security recommendations
        pentest_results.add_recommendation(
            "Implement Web Application Firewall (WAF) for additional protection"
        )
        pentest_results.add_recommendation(
            "Set up real-time security monitoring and alerting"
        )
        pentest_results.add_recommendation(
            "Conduct regular security audits and penetration testing"
        )
        pentest_results.add_recommendation(
            "Implement additional fraud detection mechanisms"
        )
        
        # Generate report
        summary = pentest_results.get_summary()
        
        report = {
            "penetration_test_report": {
                "timestamp": datetime.utcnow().isoformat(),
                "summary": summary,
                "test_results": pentest_results.test_results,
                "vulnerabilities": pentest_results.vulnerabilities,
                "recommendations": pentest_results.recommendations
            }
        }
        
        # Save report to file
        import json
        with open("pentest_report.json", "w") as f:
            json.dump(report, f, indent=2)
        
        print("\n" + "="*80)
        print("PENETRATION TEST SUMMARY")
        print("="*80)
        print(f"Total Tests: {summary['total_tests']}")
        print(f"Passed: {summary['passed_tests']}")
        print(f"Failed: {summary['failed_tests']}")
        print(f"Vulnerabilities Found: {summary['vulnerabilities']}")
        print("\nRisk Distribution:")
        for risk, count in summary['risk_distribution'].items():
            if count > 0:
                print(f"  {risk}: {count}")
        print(f"\nRecommendations: {summary['recommendations_count']}")
        print("="*80)
        
        # Assert overall security posture
        high_risk_vulns = summary['risk_distribution']['HIGH']
        medium_risk_vulns = summary['risk_distribution']['MEDIUM']
        
        if high_risk_vulns > 0:
            pytest.fail(f"HIGH RISK vulnerabilities found: {high_risk_vulns}")
        elif medium_risk_vulns > 3:
            pytest.fail(f"Too many MEDIUM RISK vulnerabilities: {medium_risk_vulns}")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-m", "pentest"])