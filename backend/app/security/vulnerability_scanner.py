"""
Security vulnerability scanner for authentication system
Automated security validation and vulnerability detection
"""

import asyncio
import json
import time
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from uuid import uuid4
import re
import hashlib
import secrets
from dataclasses import dataclass
from enum import Enum

from app.core.config import settings
from app.core.security import security
from app.services.redis_service import redis_service
from app.models.auth import UserProfile, AuthAttempt, PasswordResetToken
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func


class RiskLevel(Enum):
    """Risk level enumeration"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


@dataclass
class SecurityFinding:
    """Security finding data structure"""
    id: str
    title: str
    description: str
    risk_level: RiskLevel
    category: str
    affected_component: str
    recommendation: str
    technical_details: Dict[str, Any]
    timestamp: datetime


class SecurityScanner:
    """Comprehensive security vulnerability scanner"""
    
    def __init__(self, db_session: AsyncSession):
        self.db = db_session
        self.findings: List[SecurityFinding] = []
        self.scan_start_time = datetime.utcnow()
    
    async def run_full_scan(self) -> Dict[str, Any]:
        """Run comprehensive security scan"""
        print("Starting comprehensive security vulnerability scan...")
        
        # Configuration Security
        await self._scan_configuration_security()
        
        # Authentication Security
        await self._scan_authentication_security()
        
        # Session Management Security
        await self._scan_session_security()
        
        # Token Security
        await self._scan_token_security()
        
        # Database Security
        await self._scan_database_security()
        
        # Rate Limiting Security
        await self._scan_rate_limiting()
        
        # Password Security
        await self._scan_password_security()
        
        # MFA Security
        await self._scan_mfa_security()
        
        # Audit Logging Security
        await self._scan_audit_security()
        
        # Generate report
        return await self._generate_security_report()
    
    async def _scan_configuration_security(self):
        """Scan configuration security"""
        print("Scanning configuration security...")
        
        # Check JWT secret strength
        if len(settings.JWT_SECRET_KEY) < 32:
            self._add_finding(
                "Weak JWT Secret Key",
                "JWT secret key is too short, making it vulnerable to brute force attacks",
                RiskLevel.HIGH,
                "Configuration",
                "JWT Settings",
                "Use a JWT secret key of at least 32 characters with high entropy",
                {"current_length": len(settings.JWT_SECRET_KEY)}
            )
        
        # Check if using production-ready algorithm
        if settings.JWT_ALGORITHM not in ["RS256", "ES256"]:
            self._add_finding(
                "Insecure JWT Algorithm",
                f"Using {settings.JWT_ALGORITHM} which may be less secure than RS256/ES256",
                RiskLevel.MEDIUM,
                "Configuration",
                "JWT Settings",
                "Use RS256 or ES256 for better security",
                {"current_algorithm": settings.JWT_ALGORITHM}
            )
        
        # Check token expiration times
        if settings.ACCESS_TOKEN_EXPIRE_MINUTES > 60:
            self._add_finding(
                "Long Token Expiration",
                "Access tokens have long expiration time, increasing exposure window",
                RiskLevel.MEDIUM,
                "Configuration",
                "Token Settings",
                "Reduce access token expiration to 15-30 minutes",
                {"current_expiration": settings.ACCESS_TOKEN_EXPIRE_MINUTES}
            )
        
        # Check password policy strength
        if settings.PASSWORD_MIN_LENGTH < 12:
            self._add_finding(
                "Weak Password Policy",
                "Minimum password length is too short",
                RiskLevel.MEDIUM,
                "Configuration",
                "Password Policy",
                "Require passwords of at least 12 characters",
                {"current_min_length": settings.PASSWORD_MIN_LENGTH}
            )
        
        # Check lockout settings
        if settings.MAX_LOGIN_ATTEMPTS > 5:
            self._add_finding(
                "Permissive Account Lockout",
                "Too many login attempts allowed before lockout",
                RiskLevel.LOW,
                "Configuration",
                "Account Lockout",
                "Reduce maximum login attempts to 3-5",
                {"current_max_attempts": settings.MAX_LOGIN_ATTEMPTS}
            )
        
        # Check session settings
        if settings.SESSION_EXPIRE_HOURS > 24:
            self._add_finding(
                "Long Session Expiration",
                "Sessions have very long expiration times",
                RiskLevel.MEDIUM,
                "Configuration",
                "Session Management",
                "Reduce session expiration to 8-12 hours",
                {"current_expiration_hours": settings.SESSION_EXPIRE_HOURS}
            )
        
        # Check if debug mode is enabled
        if settings.DEBUG and settings.is_production:
            self._add_finding(
                "Debug Mode in Production",
                "Debug mode is enabled in production environment",
                RiskLevel.CRITICAL,
                "Configuration",
                "Environment",
                "Disable debug mode in production",
                {"debug_enabled": settings.DEBUG, "environment": settings.ENVIRONMENT}
            )
    
    async def _scan_authentication_security(self):
        """Scan authentication security"""
        print("Scanning authentication security...")
        
        # Check for default accounts
        default_emails = ["admin@admin.com", "test@test.com", "user@user.com"]
        
        for email in default_emails:
            result = await self.db.execute(
                select(UserProfile).where(UserProfile.email == email)
            )
            if result.scalar_one_or_none():
                self._add_finding(
                    "Default Account Found",
                    f"Default account with email {email} exists",
                    RiskLevel.HIGH,
                    "Authentication",
                    "User Management",
                    "Remove or rename default accounts",
                    {"email": email}
                )
        
        # Check for users without MFA
        result = await self.db.execute(
            select(func.count(UserProfile.id)).where(
                UserProfile.mfa_enabled == False,
                UserProfile.auth_status == 'active'
            )
        )
        users_without_mfa = result.scalar()
        
        if users_without_mfa > 0:
            self._add_finding(
                "Users Without MFA",
                f"{users_without_mfa} active users do not have MFA enabled",
                RiskLevel.MEDIUM,
                "Authentication",
                "Multi-Factor Authentication",
                "Enforce MFA for all users or implement conditional MFA",
                {"users_count": users_without_mfa}
            )
        
        # Check for accounts with weak passwords (simplified check)
        result = await self.db.execute(
            select(UserProfile).where(UserProfile.auth_status == 'active').limit(10)
        )
        
        weak_password_indicators = 0
        for user in result.scalars():
            # This is a simplified check - in reality, we can't check actual passwords
            # But we can check password change frequency, etc.
            if user.password_changed_at is None:
                weak_password_indicators += 1
        
        if weak_password_indicators > 0:
            self._add_finding(
                "Users Never Changed Password",
                f"{weak_password_indicators} users have never changed their password",
                RiskLevel.LOW,
                "Authentication",
                "Password Management",
                "Implement password aging and force password changes",
                {"users_count": weak_password_indicators}
            )
    
    async def _scan_session_security(self):
        """Scan session management security"""
        print("Scanning session security...")
        
        # Check for long-running sessions
        threshold = datetime.utcnow() - timedelta(days=30)
        result = await self.db.execute(
            select(func.count()).where(
                UserProfile.last_login < threshold,
                UserProfile.auth_status == 'active'
            )
        )
        stale_sessions = result.scalar()
        
        if stale_sessions > 0:
            self._add_finding(
                "Stale User Sessions",
                f"{stale_sessions} users have not logged in for over 30 days",
                RiskLevel.LOW,
                "Session Management",
                "Session Cleanup",
                "Implement automatic account deactivation for inactive users",
                {"stale_count": stale_sessions}
            )
        
        # Check concurrent session limits
        if settings.MAX_CONCURRENT_SESSIONS > 5:
            self._add_finding(
                "High Concurrent Session Limit",
                "Users can have too many concurrent sessions",
                RiskLevel.MEDIUM,
                "Session Management",
                "Session Limits",
                "Reduce maximum concurrent sessions to 3-5",
                {"current_limit": settings.MAX_CONCURRENT_SESSIONS}
            )
    
    async def _scan_token_security(self):
        """Scan token security"""
        print("Scanning token security...")
        
        # Test token generation entropy
        tokens = set()
        for _ in range(1000):
            token = security.generate_secure_token(32)
            tokens.add(token)
        
        if len(tokens) < 1000:
            self._add_finding(
                "Poor Token Entropy",
                f"Token generation shows poor entropy - only {len(tokens)}/1000 unique",
                RiskLevel.HIGH,
                "Token Security",
                "Token Generation",
                "Improve token generation algorithm to use cryptographically secure randomness",
                {"unique_tokens": len(tokens), "total_generated": 1000}
            )
        
        # Check token blacklisting mechanism
        try:
            test_token = "test_blacklist_token"
            await redis_service.blacklist_token(test_token)
            is_blacklisted = await redis_service.is_token_blacklisted(test_token)
            
            if not is_blacklisted:
                self._add_finding(
                    "Token Blacklisting Failure",
                    "Token blacklisting mechanism is not working properly",
                    RiskLevel.HIGH,
                    "Token Security",
                    "Token Blacklisting",
                    "Fix token blacklisting implementation",
                    {"test_result": "blacklisting_failed"}
                )
        except Exception as e:
            self._add_finding(
                "Token Blacklisting Error",
                f"Error testing token blacklisting: {str(e)}",
                RiskLevel.MEDIUM,
                "Token Security",
                "Token Blacklisting",
                "Investigate and fix token blacklisting errors",
                {"error": str(e)}
            )
    
    async def _scan_database_security(self):
        """Scan database security"""
        print("Scanning database security...")
        
        # Check for SQL injection vulnerabilities (basic test)
        injection_payloads = ["'; DROP TABLE users; --", "' OR '1'='1"]
        
        for payload in injection_payloads:
            try:
                # Test with parameterized query (should be safe)
                result = await self.db.execute(
                    select(UserProfile).where(UserProfile.email == payload)
                )
                # If we get here without error, parameterization is working
            except Exception as e:
                if "syntax error" in str(e).lower() or "sql" in str(e).lower():
                    self._add_finding(
                        "Potential SQL Injection Vulnerability",
                        f"Database query with payload '{payload}' caused SQL error",
                        RiskLevel.HIGH,
                        "Database Security",
                        "SQL Injection",
                        "Ensure all database queries use parameterized statements",
                        {"payload": payload, "error": str(e)}
                    )
        
        # Check password storage
        result = await self.db.execute(
            select(UserProfile.password_hash).limit(1)
        )
        sample_hash = result.scalar()
        
        if sample_hash:
            # Check if password is properly hashed (bcrypt starts with $2b$)
            if not sample_hash.startswith("$2b$"):
                self._add_finding(
                    "Weak Password Hashing",
                    "Passwords may not be using bcrypt hashing",
                    RiskLevel.CRITICAL,
                    "Database Security",
                    "Password Storage",
                    "Use bcrypt or similar strong hashing algorithm for passwords",
                    {"hash_format": sample_hash[:10] + "..."}
                )
        
        # Check for sensitive data in logs (simplified)
        # In a real implementation, this would scan actual log files
        pass
    
    async def _scan_rate_limiting(self):
        """Scan rate limiting security"""
        print("Scanning rate limiting security...")
        
        # Test rate limiting functionality
        test_key = f"security_scan_{uuid4()}"
        
        # Make requests to test rate limiting
        attempts = 0
        rate_limited = False
        
        for i in range(10):
            allowed = await redis_service.check_rate_limit(test_key, limit=5, window=60)
            if not allowed:
                rate_limited = True
                break
            attempts += 1
        
        if not rate_limited:
            self._add_finding(
                "Rate Limiting Not Working",
                "Rate limiting mechanism is not functioning properly",
                RiskLevel.HIGH,
                "Rate Limiting",
                "Rate Control",
                "Fix rate limiting implementation",
                {"attempts_before_limit": attempts}
            )
        elif attempts > 5:
            self._add_finding(
                "Rate Limiting Too Permissive",
                f"Rate limiting allows {attempts} attempts before blocking",
                RiskLevel.MEDIUM,
                "Rate Limiting",
                "Rate Control",
                "Tighten rate limiting thresholds",
                {"actual_limit": attempts, "expected_limit": 5}
            )
        
        # Clean up test key
        await redis_service.client.delete(f"rate_limit:{test_key}")
    
    async def _scan_password_security(self):
        """Scan password security policies"""
        print("Scanning password security...")
        
        # Test password validation
        weak_passwords = [
            "password", "123456", "qwerty", "abc123", "password123"
        ]
        
        validation_bypassed = []
        
        for weak_password in weak_passwords:
            is_valid, errors = security.validate_password(weak_password)
            if is_valid:
                validation_bypassed.append(weak_password)
        
        if validation_bypassed:
            self._add_finding(
                "Weak Password Validation",
                f"Password validation allows weak passwords: {', '.join(validation_bypassed)}",
                RiskLevel.HIGH,
                "Password Security",
                "Password Validation",
                "Strengthen password validation rules",
                {"weak_passwords_allowed": validation_bypassed}
            )
        
        # Check password history enforcement
        if settings.PASSWORD_HISTORY_COUNT < 3:
            self._add_finding(
                "Insufficient Password History",
                "Password history count is too low",
                RiskLevel.MEDIUM,
                "Password Security",
                "Password History",
                "Increase password history to at least 5 previous passwords",
                {"current_history_count": settings.PASSWORD_HISTORY_COUNT}
            )
    
    async def _scan_mfa_security(self):
        """Scan MFA security"""
        print("Scanning MFA security...")
        
        # Check MFA settings
        if settings.MFA_DIGITS < 6:
            self._add_finding(
                "Weak MFA Code Length",
                "MFA codes are too short",
                RiskLevel.MEDIUM,
                "MFA Security",
                "TOTP Configuration",
                "Use at least 6-digit MFA codes",
                {"current_digits": settings.MFA_DIGITS}
            )
        
        if settings.MFA_PERIOD > 30:
            self._add_finding(
                "Long MFA Period",
                "MFA time period is too long",
                RiskLevel.LOW,
                "MFA Security",
                "TOTP Configuration",
                "Use standard 30-second TOTP period",
                {"current_period": settings.MFA_PERIOD}
            )
        
        # Check backup codes
        if settings.MFA_BACKUP_CODES_COUNT < 8:
            self._add_finding(
                "Insufficient Backup Codes",
                "Not enough MFA backup codes generated",
                RiskLevel.LOW,
                "MFA Security",
                "Backup Codes",
                "Generate at least 8-10 backup codes",
                {"current_count": settings.MFA_BACKUP_CODES_COUNT}
            )
    
    async def _scan_audit_security(self):
        """Scan audit logging security"""
        print("Scanning audit security...")
        
        # Check if audit logging is enabled
        if not settings.ENABLE_AUDIT_LOG:
            self._add_finding(
                "Audit Logging Disabled",
                "Audit logging is disabled",
                RiskLevel.HIGH,
                "Audit Security",
                "Logging Configuration",
                "Enable comprehensive audit logging",
                {"audit_enabled": settings.ENABLE_AUDIT_LOG}
            )
        
        # Check audit log retention (simplified)
        old_threshold = datetime.utcnow() - timedelta(days=90)
        result = await self.db.execute(
            select(func.count()).where(AuthAttempt.attempted_at < old_threshold)
        )
        old_logs_count = result.scalar()
        
        if old_logs_count > 10000:
            self._add_finding(
                "Excessive Old Audit Logs",
                f"Too many old audit logs ({old_logs_count}) may impact performance",
                RiskLevel.LOW,
                "Audit Security",
                "Log Retention",
                "Implement audit log archival and cleanup processes",
                {"old_logs_count": old_logs_count}
            )
    
    def _add_finding(
        self,
        title: str,
        description: str,
        risk_level: RiskLevel,
        category: str,
        component: str,
        recommendation: str,
        technical_details: Dict[str, Any]
    ):
        """Add security finding"""
        finding = SecurityFinding(
            id=str(uuid4()),
            title=title,
            description=description,
            risk_level=risk_level,
            category=category,
            affected_component=component,
            recommendation=recommendation,
            technical_details=technical_details,
            timestamp=datetime.utcnow()
        )
        self.findings.append(finding)
        
        # Print finding immediately for visibility
        risk_color = {
            RiskLevel.CRITICAL: "ðŸ”´",
            RiskLevel.HIGH: "ðŸŸ ", 
            RiskLevel.MEDIUM: "ðŸŸ¡",
            RiskLevel.LOW: "ðŸ”µ",
            RiskLevel.INFO: "âšª"
        }
        
        print(f"{risk_color[risk_level]} {risk_level.value}: {title}")
    
    async def _generate_security_report(self) -> Dict[str, Any]:
        """Generate comprehensive security report"""
        scan_duration = datetime.utcnow() - self.scan_start_time
        
        # Categorize findings by risk level
        risk_distribution = {level: 0 for level in RiskLevel}
        category_distribution = {}
        
        for finding in self.findings:
            risk_distribution[finding.risk_level] += 1
            
            if finding.category not in category_distribution:
                category_distribution[finding.category] = 0
            category_distribution[finding.category] += 1
        
        # Calculate overall security score (0-100)
        total_findings = len(self.findings)
        if total_findings == 0:
            security_score = 100
        else:
            # Weight findings by severity
            weighted_score = (
                risk_distribution[RiskLevel.CRITICAL] * 25 +
                risk_distribution[RiskLevel.HIGH] * 15 +
                risk_distribution[RiskLevel.MEDIUM] * 8 +
                risk_distribution[RiskLevel.LOW] * 3 +
                risk_distribution[RiskLevel.INFO] * 1
            )
            
            # Calculate score (max possible would be if all findings were critical)
            max_possible_score = total_findings * 25
            security_score = max(0, 100 - (weighted_score / max_possible_score * 100))
        
        # Generate recommendations priority list
        priority_recommendations = []
        for finding in sorted(self.findings, key=lambda x: x.risk_level.value):
            if finding.risk_level in [RiskLevel.CRITICAL, RiskLevel.HIGH]:
                priority_recommendations.append({
                    "title": finding.title,
                    "recommendation": finding.recommendation,
                    "risk_level": finding.risk_level.value
                })
        
        report = {
            "security_scan_report": {
                "scan_metadata": {
                    "scan_id": str(uuid4()),
                    "timestamp": datetime.utcnow().isoformat(),
                    "duration_seconds": scan_duration.total_seconds(),
                    "scanner_version": "1.0.0"
                },
                "summary": {
                    "total_findings": total_findings,
                    "security_score": round(security_score, 2),
                    "risk_distribution": {k.value: v for k, v in risk_distribution.items()},
                    "category_distribution": category_distribution
                },
                "findings": [
                    {
                        "id": finding.id,
                        "title": finding.title,
                        "description": finding.description,
                        "risk_level": finding.risk_level.value,
                        "category": finding.category,
                        "affected_component": finding.affected_component,
                        "recommendation": finding.recommendation,
                        "technical_details": finding.technical_details,
                        "timestamp": finding.timestamp.isoformat()
                    }
                    for finding in self.findings
                ],
                "priority_recommendations": priority_recommendations
            }
        }
        
        # Save report
        with open(f"security_scan_report_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json", "w") as f:
            json.dump(report, f, indent=2)
        
        print(f"\n{'='*60}")
        print("SECURITY SCAN COMPLETED")
        print(f"{'='*60}")
        print(f"Security Score: {security_score:.1f}/100")
        print(f"Total Findings: {total_findings}")
        print(f"Critical: {risk_distribution[RiskLevel.CRITICAL]}")
        print(f"High: {risk_distribution[RiskLevel.HIGH]}")
        print(f"Medium: {risk_distribution[RiskLevel.MEDIUM]}")
        print(f"Low: {risk_distribution[RiskLevel.LOW]}")
        print(f"Scan Duration: {scan_duration.total_seconds():.1f} seconds")
        print(f"{'='*60}")
        
        return report


async def run_security_scan(db_session: AsyncSession) -> Dict[str, Any]:
    """Run comprehensive security scan"""
    scanner = SecurityScanner(db_session)
    return await scanner.run_full_scan()